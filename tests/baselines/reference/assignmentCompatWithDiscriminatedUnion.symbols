=== tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts ===
// see 'typeRelatedToDiscriminatedType' in checker.ts:

// IteratorResult
namespace Example1 {
>Example1 : Symbol(Example1, Decl(assignmentCompatWithDiscriminatedUnion.ts, 0, 0))

    type S = { done: boolean, value: number };
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 3, 20))
>done : Symbol(done, Decl(assignmentCompatWithDiscriminatedUnion.ts, 4, 14))
>value : Symbol(value, Decl(assignmentCompatWithDiscriminatedUnion.ts, 4, 29))

    type T =
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 4, 46))

        | { done: true, value: number }     // T0
>done : Symbol(done, Decl(assignmentCompatWithDiscriminatedUnion.ts, 6, 11))
>value : Symbol(value, Decl(assignmentCompatWithDiscriminatedUnion.ts, 6, 23))

        | { done: false, value: number };   // T1
>done : Symbol(done, Decl(assignmentCompatWithDiscriminatedUnion.ts, 7, 11))
>value : Symbol(value, Decl(assignmentCompatWithDiscriminatedUnion.ts, 7, 24))

    declare let s: S;
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 9, 15))
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 3, 20))

    declare let t: T;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 10, 15))
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 4, 46))

    // S is assignable to T0 when S["done"] is true
    // S is assignable to T1 when S["done"] is false
    t = s;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 10, 15))
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 9, 15))
}

// Dropping constituents of T
namespace Example2 {
>Example2 : Symbol(Example2, Decl(assignmentCompatWithDiscriminatedUnion.ts, 15, 1))

    type S = { a: 0 | 2, b: 4 };
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 18, 20))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 19, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 19, 24))

    type T = { a: 0,     b: 1 | 4 }     // T0
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 19, 32))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 20, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 20, 20))

           | { a: 1,     b: 2 }         // T1
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 21, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 21, 20))

           | { a: 2,     b: 3 | 4 };    // T2
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 22, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 22, 20))

    declare let s: S;
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 23, 15))
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 18, 20))

    declare let t: T;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 24, 15))
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 19, 32))

    // S is assignable to T0 when S["a"] is 0
    // S is assignable to T2 when S["a"] is 2
    t = s;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 24, 15))
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 23, 15))
}

// Unmatched discriminants
namespace Example3 {
>Example3 : Symbol(Example3, Decl(assignmentCompatWithDiscriminatedUnion.ts, 29, 1))

    type S = { a: 0 | 2, b: 4 };
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 32, 20))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 33, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 33, 24))

    type T = { a: 0,     b: 1 | 4 }     // T0
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 33, 32))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 34, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 34, 20))

           | { a: 1,     b: 2 | 4 }     // T1
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 35, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 35, 20))

           | { a: 2,     b: 3 };        // T2
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 36, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 36, 20))

    declare let s: S;
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 37, 15))
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 32, 20))

    declare let t: T;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 38, 15))
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 33, 32))

    // S is assignable to T0 when S["a"] is 0
    // S is *not* assignable to T1 when S["b"] is 4
    // S is *not* assignable to T2 when S["a"] is 2
    t = s;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 38, 15))
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 37, 15))
}

// Unmatched non-discriminants
namespace Example4 {
>Example4 : Symbol(Example4, Decl(assignmentCompatWithDiscriminatedUnion.ts, 44, 1))

    type S = { a: 0 | 2, b: 4 };
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 47, 20))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 48, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 48, 24))

    type T = { a: 0,     b: 1 | 4 }             // T0
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 48, 32))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 49, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 49, 20))

           | { a: 1,     b: 2 }                 // T1
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 50, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 50, 20))

           | { a: 2,     b: 3 | 4, c: string }; // T2
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 51, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 51, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 51, 34))

    declare let s: S;
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 52, 15))
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 47, 20))

    declare let t: T;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 53, 15))
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 48, 32))

    // S is assignable to T0 when S["a"] is 0
    // S is *not* assignable to T2 when S["a"] is 2 as S is missing "c"
    t = s;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 53, 15))
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 52, 15))
}

// Maximum discriminant combinations
namespace Example5 {
>Example5 : Symbol(Example5, Decl(assignmentCompatWithDiscriminatedUnion.ts, 58, 1))

    // NOTE: MAX_DISCRIMINANT_COMBINATIONS is currently 25
    //       3 discriminant properties with 3 types a piece
    //       is 27 possible combinations.
    type N = 0 | 1 | 2;
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

    type S = { a: N, b: N, c: N };
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 65, 23))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 66, 14))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 66, 20))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 66, 26))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

    type T = { a: 0, b: N, c: N }
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 66, 34))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 67, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 67, 20))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 67, 26))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

           | { a: 1, b: N, c: N }
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 68, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 68, 20))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 68, 26))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

           | { a: 2, b: N, c: N }
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 69, 14))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 69, 20))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 69, 26))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

           | { a: N, b: 0, c: N }
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 70, 14))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 70, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 70, 26))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

           | { a: N, b: 1, c: N }
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 71, 14))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 71, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 71, 26))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

           | { a: N, b: 2, c: N }
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 72, 14))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 72, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 72, 26))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))

           | { a: N, b: N, c: 0 }
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 73, 14))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 73, 20))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 73, 26))

           | { a: N, b: N, c: 1 }
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 74, 14))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 74, 20))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 74, 26))

           | { a: N, b: N, c: 2 };
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 75, 14))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 75, 20))
>N : Symbol(N, Decl(assignmentCompatWithDiscriminatedUnion.ts, 61, 20))
>c : Symbol(c, Decl(assignmentCompatWithDiscriminatedUnion.ts, 75, 26))

    declare let s: S;
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 76, 15))
>S : Symbol(S, Decl(assignmentCompatWithDiscriminatedUnion.ts, 65, 23))

    declare let t: T;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 77, 15))
>T : Symbol(T, Decl(assignmentCompatWithDiscriminatedUnion.ts, 66, 34))

    // S *should* be assignable but the number of
    // combinations is too complex.
    t = s;
>t : Symbol(t, Decl(assignmentCompatWithDiscriminatedUnion.ts, 77, 15))
>s : Symbol(s, Decl(assignmentCompatWithDiscriminatedUnion.ts, 76, 15))
}

// https://github.com/Microsoft/TypeScript/issues/14865
namespace Example6 {
>Example6 : Symbol(Example6, Decl(assignmentCompatWithDiscriminatedUnion.ts, 82, 1))

    type Style1 = {
>Style1 : Symbol(Style1, Decl(assignmentCompatWithDiscriminatedUnion.ts, 85, 20))

        type: "A";
>type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 86, 19))

        data: string;
>data : Symbol(data, Decl(assignmentCompatWithDiscriminatedUnion.ts, 87, 18))

    } | {
        type: "B";
>type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 89, 9))

        data: string;
>data : Symbol(data, Decl(assignmentCompatWithDiscriminatedUnion.ts, 90, 18))

    };

    type Style2 = {
>Style2 : Symbol(Style2, Decl(assignmentCompatWithDiscriminatedUnion.ts, 92, 6))

        type: "A" | "B";
>type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 94, 19))

        data: string;
>data : Symbol(data, Decl(assignmentCompatWithDiscriminatedUnion.ts, 95, 24))
    }

    const a: Style2 = { type: "A", data: "whatevs" };
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 99, 9))
>Style2 : Symbol(Style2, Decl(assignmentCompatWithDiscriminatedUnion.ts, 92, 6))
>type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 99, 23))
>data : Symbol(data, Decl(assignmentCompatWithDiscriminatedUnion.ts, 99, 34))

    let b: Style1;
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 100, 7))
>Style1 : Symbol(Style1, Decl(assignmentCompatWithDiscriminatedUnion.ts, 85, 20))

    a.type; // "A" | "B"
>a.type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 94, 19))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 99, 9))
>type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 94, 19))

    b.type; // "A" | "B"
>b.type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 86, 19), Decl(assignmentCompatWithDiscriminatedUnion.ts, 89, 9))
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 100, 7))
>type : Symbol(type, Decl(assignmentCompatWithDiscriminatedUnion.ts, 86, 19), Decl(assignmentCompatWithDiscriminatedUnion.ts, 89, 9))

    b = a; // should be assignable
>b : Symbol(b, Decl(assignmentCompatWithDiscriminatedUnion.ts, 100, 7))
>a : Symbol(a, Decl(assignmentCompatWithDiscriminatedUnion.ts, 99, 9))
}
