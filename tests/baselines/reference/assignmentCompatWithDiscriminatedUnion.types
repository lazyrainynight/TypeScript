=== tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts ===
// see 'typeRelatedToDiscriminatedType' in checker.ts:

// IteratorResult
namespace Example1 {
>Example1 : typeof Example1

    type S = { done: boolean, value: number };
>S : S
>done : boolean
>value : number

    type T =
>T : T

        | { done: true, value: number }     // T0
>done : true
>true : true
>value : number

        | { done: false, value: number };   // T1
>done : false
>false : false
>value : number

    declare let s: S;
>s : S

    declare let t: T;
>t : T

    // S is assignable to T0 when S["done"] is true
    // S is assignable to T1 when S["done"] is false
    t = s;
>t = s : S
>t : T
>s : S
}

// Dropping constituents of T
namespace Example2 {
>Example2 : typeof Example2

    type S = { a: 0 | 2, b: 4 };
>S : S
>a : 0 | 2
>b : 4

    type T = { a: 0,     b: 1 | 4 }     // T0
>T : T
>a : 0
>b : 4 | 1

           | { a: 1,     b: 2 }         // T1
>a : 1
>b : 2

           | { a: 2,     b: 3 | 4 };    // T2
>a : 2
>b : 4 | 3

    declare let s: S;
>s : S

    declare let t: T;
>t : T

    // S is assignable to T0 when S["a"] is 0
    // S is assignable to T2 when S["a"] is 2
    t = s;
>t = s : S
>t : T
>s : S
}

// Unmatched discriminants
namespace Example3 {
>Example3 : typeof Example3

    type S = { a: 0 | 2, b: 4 };
>S : S
>a : 0 | 2
>b : 4

    type T = { a: 0,     b: 1 | 4 }     // T0
>T : T
>a : 0
>b : 4 | 1

           | { a: 1,     b: 2 | 4 }     // T1
>a : 1
>b : 2 | 4

           | { a: 2,     b: 3 };        // T2
>a : 2
>b : 3

    declare let s: S;
>s : S

    declare let t: T;
>t : T

    // S is assignable to T0 when S["a"] is 0
    // S is *not* assignable to T1 when S["b"] is 4
    // S is *not* assignable to T2 when S["a"] is 2
    t = s;
>t = s : S
>t : T
>s : S
}

// Unmatched non-discriminants
namespace Example4 {
>Example4 : typeof Example4

    type S = { a: 0 | 2, b: 4 };
>S : S
>a : 0 | 2
>b : 4

    type T = { a: 0,     b: 1 | 4 }             // T0
>T : T
>a : 0
>b : 4 | 1

           | { a: 1,     b: 2 }                 // T1
>a : 1
>b : 2

           | { a: 2,     b: 3 | 4, c: string }; // T2
>a : 2
>b : 4 | 3
>c : string

    declare let s: S;
>s : S

    declare let t: T;
>t : T

    // S is assignable to T0 when S["a"] is 0
    // S is *not* assignable to T2 when S["a"] is 2 as S is missing "c"
    t = s;
>t = s : S
>t : T
>s : S
}

// Maximum discriminant combinations
namespace Example5 {
>Example5 : typeof Example5

    // NOTE: MAX_DISCRIMINANT_COMBINATIONS is currently 25
    //       3 discriminant properties with 3 types a piece
    //       is 27 possible combinations.
    type N = 0 | 1 | 2;
>N : 0 | 2 | 1

    type S = { a: N, b: N, c: N };
>S : S
>a : 0 | 2 | 1
>b : 0 | 2 | 1
>c : 0 | 2 | 1

    type T = { a: 0, b: N, c: N }
>T : T
>a : 0
>b : 0 | 2 | 1
>c : 0 | 2 | 1

           | { a: 1, b: N, c: N }
>a : 1
>b : 0 | 2 | 1
>c : 0 | 2 | 1

           | { a: 2, b: N, c: N }
>a : 2
>b : 0 | 2 | 1
>c : 0 | 2 | 1

           | { a: N, b: 0, c: N }
>a : 0 | 2 | 1
>b : 0
>c : 0 | 2 | 1

           | { a: N, b: 1, c: N }
>a : 0 | 2 | 1
>b : 1
>c : 0 | 2 | 1

           | { a: N, b: 2, c: N }
>a : 0 | 2 | 1
>b : 2
>c : 0 | 2 | 1

           | { a: N, b: N, c: 0 }
>a : 0 | 2 | 1
>b : 0 | 2 | 1
>c : 0

           | { a: N, b: N, c: 1 }
>a : 0 | 2 | 1
>b : 0 | 2 | 1
>c : 1

           | { a: N, b: N, c: 2 };
>a : 0 | 2 | 1
>b : 0 | 2 | 1
>c : 2

    declare let s: S;
>s : S

    declare let t: T;
>t : T

    // S *should* be assignable but the number of
    // combinations is too complex.
    t = s;
>t = s : S
>t : T
>s : S
}

// https://github.com/Microsoft/TypeScript/issues/14865
namespace Example6 {
>Example6 : typeof Example6

    type Style1 = {
>Style1 : Style1

        type: "A";
>type : "A"

        data: string;
>data : string

    } | {
        type: "B";
>type : "B"

        data: string;
>data : string

    };

    type Style2 = {
>Style2 : Style2

        type: "A" | "B";
>type : "A" | "B"

        data: string;
>data : string
    }

    const a: Style2 = { type: "A", data: "whatevs" };
>a : Style2
>{ type: "A", data: "whatevs" } : { type: "A"; data: string; }
>type : "A"
>"A" : "A"
>data : string
>"whatevs" : "whatevs"

    let b: Style1;
>b : Style1

    a.type; // "A" | "B"
>a.type : "A" | "B"
>a : Style2
>type : "A" | "B"

    b.type; // "A" | "B"
>b.type : "A" | "B"
>b : Style1
>type : "A" | "B"

    b = a; // should be assignable
>b = a : Style2
>b : Style1
>a : Style2
}
